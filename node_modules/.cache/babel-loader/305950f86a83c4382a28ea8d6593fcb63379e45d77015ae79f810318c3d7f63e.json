{"ast":null,"code":"import { Account, Address, Contract, Operation, SorobanRpc, StrKey, TimeoutInfinite, TransactionBuilder, authorizeEntry, hash, xdr, BASE_FEE } from \"stellar-sdk\";\nimport { Buffer } from \"buffer\";\nexport class ExpiredStateError extends Error {}\nexport class NeedsMoreSignaturesError extends Error {}\nexport class WalletDisconnectedError extends Error {}\nexport class SendResultOnlyError extends Error {}\nexport class SendFailedError extends Error {}\nexport class NoUnsignedNonInvokerAuthEntriesError extends Error {}\nexport { Address };\n;\n;\nexport class Ok {\n  value;\n  constructor(value) {\n    this.value = value;\n  }\n  unwrapErr() {\n    throw new Error('No error');\n  }\n  unwrap() {\n    return this.value;\n  }\n  isOk() {\n    return true;\n  }\n  isErr() {\n    return !this.isOk();\n  }\n}\nexport class Err {\n  error;\n  constructor(error) {\n    this.error = error;\n  }\n  unwrapErr() {\n    return this.error;\n  }\n  unwrap() {\n    throw new Error(this.error.message);\n  }\n  isOk() {\n    return false;\n  }\n  isErr() {\n    return !this.isOk();\n  }\n}\nexport const contractErrorPattern = /Error\\(Contract, #(\\d+)\\)/;\nexport const NULL_ACCOUNT = \"GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF\";\nexport class AssembledTransaction {\n  options;\n  raw;\n  simulation;\n  simulationResult;\n  simulationTransactionData;\n  server;\n  toJSON() {\n    return JSON.stringify({\n      method: this.options.method,\n      tx: this.raw?.toXDR(),\n      simulationResult: {\n        auth: this.simulationData.result.auth.map(a => a.toXDR('base64')),\n        retval: this.simulationData.result.retval.toXDR('base64')\n      },\n      simulationTransactionData: this.simulationData.transactionData.toXDR('base64')\n    });\n  }\n  static fromJSON(options, {\n    tx,\n    simulationResult,\n    simulationTransactionData\n  }) {\n    const txn = new AssembledTransaction(options);\n    txn.raw = TransactionBuilder.fromXDR(tx, options.networkPassphrase);\n    txn.simulationResult = {\n      auth: simulationResult.auth.map(a => xdr.SorobanAuthorizationEntry.fromXDR(a, 'base64')),\n      retval: xdr.ScVal.fromXDR(simulationResult.retval, 'base64')\n    };\n    txn.simulationTransactionData = xdr.SorobanTransactionData.fromXDR(simulationTransactionData, 'base64');\n    return txn;\n  }\n  constructor(options) {\n    this.options = options;\n    this.server = new SorobanRpc.Server(this.options.rpcUrl, {\n      allowHttp: this.options.rpcUrl.startsWith(\"http://\")\n    });\n  }\n  static async fromSimulation(options) {\n    const tx = new AssembledTransaction(options);\n    const contract = new Contract(options.contractId);\n    tx.raw = new TransactionBuilder(await tx.getAccount(), {\n      fee: options.fee?.toString(10) ?? BASE_FEE,\n      networkPassphrase: options.networkPassphrase\n    }).addOperation(contract.call(options.method, ...(options.args ?? []))).setTimeout(TimeoutInfinite).build();\n    return await tx.simulate();\n  }\n  simulate = async () => {\n    if (!this.raw) throw new Error('Transaction has not yet been assembled');\n    this.simulation = await this.server.simulateTransaction(this.raw);\n    if (SorobanRpc.Api.isSimulationSuccess(this.simulation)) {\n      this.raw = SorobanRpc.assembleTransaction(this.raw, this.simulation).build();\n    }\n    return this;\n  };\n  get simulationData() {\n    if (this.simulationResult && this.simulationTransactionData) {\n      return {\n        result: this.simulationResult,\n        transactionData: this.simulationTransactionData\n      };\n    }\n    // else, we know we just did the simulation on this machine\n    const simulation = this.simulation;\n    if (SorobanRpc.Api.isSimulationError(simulation)) {\n      throw new Error(`Transaction simulation failed: \"${simulation.error}\"`);\n    }\n    if (SorobanRpc.Api.isSimulationRestore(simulation)) {\n      throw new ExpiredStateError(`You need to restore some contract state before you can invoke this method. ${JSON.stringify(simulation, null, 2)}`);\n    }\n    if (!simulation.result) {\n      throw new Error(`Expected an invocation simulation, but got no 'result' field. Simulation: ${JSON.stringify(simulation, null, 2)}`);\n    }\n    // add to object for serialization & deserialization\n    this.simulationResult = simulation.result;\n    this.simulationTransactionData = simulation.transactionData.build();\n    return {\n      result: this.simulationResult,\n      transactionData: this.simulationTransactionData\n    };\n  }\n  get result() {\n    try {\n      return this.options.parseResultXdr(this.simulationData.result.retval);\n    } catch (e) {\n      let err = this.parseError(e.toString());\n      if (err) return err;\n      throw e;\n    }\n  }\n  parseError(errorMessage) {\n    if (!this.options.errorTypes) return;\n    const match = errorMessage.match(contractErrorPattern);\n    if (!match) return;\n    let i = parseInt(match[1], 10);\n    let err = this.options.errorTypes[i];\n    if (err) return new Err(err);\n  }\n  getWallet = async () => {\n    return this.options.wallet ?? (await import(\"@stellar/freighter-api\")).default;\n  };\n  getPublicKey = async () => {\n    const wallet = await this.getWallet();\n    if ((await wallet.isConnected()) && (await wallet.isAllowed())) {\n      return (await wallet.getUserInfo()).publicKey;\n    }\n  };\n  /**\n   * Get account details from the Soroban network for the publicKey currently\n   * selected in user's wallet. If not connected to Freighter, use placeholder\n   * null account.\n   */\n  getAccount = async () => {\n    const publicKey = await this.getPublicKey();\n    return publicKey ? await this.server.getAccount(publicKey) : new Account(NULL_ACCOUNT, \"0\");\n  };\n  /**\n   * Sign the transaction with the `wallet` (default Freighter), then send to\n   * the network and return a `SentTransaction` that keeps track of all the\n   * attempts to send and fetch the transaction from the network.\n   */\n  signAndSend = async ({\n    secondsToWait = 10,\n    force = false\n  } = {}) => {\n    if (!this.raw) {\n      throw new Error('Transaction has not yet been simulated');\n    }\n    if (!force && this.isReadCall) {\n      throw new Error('This is a read call. It requires no signature or sending. Use `force: true` to sign and send anyway.');\n    }\n    if (!(await this.hasRealInvoker())) {\n      throw new WalletDisconnectedError('Wallet is not connected');\n    }\n    if (this.raw.source !== (await this.getAccount()).accountId()) {\n      throw new Error(`You must submit the transaction with the account that originally created it. Please switch to the wallet with \"${this.raw.source}\" as its public key.`);\n    }\n    if ((await this.needsNonInvokerSigningBy()).length) {\n      throw new NeedsMoreSignaturesError('Transaction requires more signatures. See `needsNonInvokerSigningBy` for details.');\n    }\n    return await SentTransaction.init(this.options, this, secondsToWait);\n  };\n  getStorageExpiration = async () => {\n    const key = new Contract(this.options.contractId).getFootprint()[1];\n    const expirationKey = xdr.LedgerKey.expiration(new xdr.LedgerKeyExpiration({\n      keyHash: hash(key.toXDR())\n    }));\n    const entryRes = await this.server.getLedgerEntries(expirationKey);\n    if (!(entryRes.entries && entryRes.entries.length)) throw new Error('failed to get ledger entry');\n    return entryRes.entries[0].val.expiration().expirationLedgerSeq();\n  };\n  /**\n   * Get a list of accounts, other than the invoker of the simulation, that\n   * need to sign auth entries in this transaction.\n   *\n   * Soroban allows multiple people to sign a transaction. Someone needs to\n   * sign the final transaction envelope; this person/account is called the\n   * _invoker_, or _source_. Other accounts might need to sign individual auth\n   * entries in the transaction, if they're not also the invoker.\n   *\n   * This function returns a list of accounts that need to sign auth entries,\n   * assuming that the same invoker/source account will sign the final\n   * transaction envelope as signed the initial simulation.\n   *\n   * One at a time, for each public key in this array, you will need to\n   * serialize this transaction with `toJSON`, send to the owner of that key,\n   * deserialize the transaction with `txFromJson`, and call\n   * {@link signAuthEntries}. Then re-serialize and send to the next account\n   * in this list.\n   */\n  needsNonInvokerSigningBy = async ({\n    includeAlreadySigned = false\n  } = {}) => {\n    if (!this.raw) {\n      throw new Error('Transaction has not yet been simulated');\n    }\n    // We expect that any transaction constructed by these libraries has a\n    // single operation, which is an InvokeHostFunction operation. The host\n    // function being invoked is the contract method call.\n    if (!(\"operations\" in this.raw)) {\n      throw new Error(`Unexpected Transaction type; no operations: ${JSON.stringify(this.raw)}`);\n    }\n    const rawInvokeHostFunctionOp = this.raw.operations[0];\n    return [...new Set((rawInvokeHostFunctionOp.auth ?? []).filter(entry => entry.credentials().switch() === xdr.SorobanCredentialsType.sorobanCredentialsAddress() && (includeAlreadySigned || entry.credentials().address().signature().switch().name === 'scvVoid')).map(entry => StrKey.encodeEd25519PublicKey(entry.credentials().address().address().accountId().ed25519())))];\n  };\n  preImageFor(entry, signatureExpirationLedger) {\n    const addrAuth = entry.credentials().address();\n    return xdr.HashIdPreimage.envelopeTypeSorobanAuthorization(new xdr.HashIdPreimageSorobanAuthorization({\n      networkId: hash(Buffer.from(this.options.networkPassphrase)),\n      nonce: addrAuth.nonce(),\n      invocation: entry.rootInvocation(),\n      signatureExpirationLedger\n    }));\n  }\n  /**\n   * If {@link needsNonInvokerSigningBy} returns a non-empty list, you can serialize\n   * the transaction with `toJSON`, send it to the owner of one of the public keys\n   * in the map, deserialize with `txFromJSON`, and call this method on their\n   * machine. Internally, this will use `signAuthEntry` function from connected\n   * `wallet` for each.\n   *\n   * Then, re-serialize the transaction and either send to the next\n   * `needsNonInvokerSigningBy` owner, or send it back to the original account\n   * who simulated the transaction so they can {@link sign} the transaction\n   * envelope and {@link send} it to the network.\n   *\n   * Sending to all `needsNonInvokerSigningBy` owners in parallel is not currently\n   * supported!\n   */\n  signAuthEntries = async (\n  /**\n   * When to set each auth entry to expire. Could be any number of blocks in\n   * the future. Can be supplied as a promise or a raw number. Default:\n   * contract's current `persistent` storage expiration date/ledger\n   * number/block.\n   */\n  expiration = this.getStorageExpiration()) => {\n    if (!this.raw) throw new Error('Transaction has not yet been assembled or simulated');\n    const needsNonInvokerSigningBy = await this.needsNonInvokerSigningBy();\n    if (!needsNonInvokerSigningBy) throw new NoUnsignedNonInvokerAuthEntriesError('No unsigned non-invoker auth entries; maybe you already signed?');\n    const publicKey = await this.getPublicKey();\n    if (!publicKey) throw new Error('Could not get public key from wallet; maybe Freighter is not signed in?');\n    if (needsNonInvokerSigningBy.indexOf(publicKey) === -1) throw new Error(`No auth entries for public key \"${publicKey}\"`);\n    const wallet = await this.getWallet();\n    const rawInvokeHostFunctionOp = this.raw.operations[0];\n    const authEntries = rawInvokeHostFunctionOp.auth ?? [];\n    for (const [i, entry] of authEntries.entries()) {\n      if (entry.credentials().switch() !== xdr.SorobanCredentialsType.sorobanCredentialsAddress()) {\n        // if the invoker/source account, then the entry doesn't need explicit\n        // signature, since the tx envelope is already signed by the source\n        // account, so only check for sorobanCredentialsAddress\n        continue;\n      }\n      const pk = StrKey.encodeEd25519PublicKey(entry.credentials().address().address().accountId().ed25519());\n      // this auth entry needs to be signed by a different account\n      // (or maybe already was!)\n      if (pk !== publicKey) continue;\n      authEntries[i] = await authorizeEntry(entry, async preimage => Buffer.from(await wallet.signAuthEntry(preimage.toXDR('base64')), 'base64'), await expiration, this.options.networkPassphrase);\n    }\n  };\n  get isReadCall() {\n    const authsCount = this.simulationData.result.auth.length;\n    const writeLength = this.simulationData.transactionData.resources().footprint().readWrite().length;\n    return authsCount === 0 && writeLength === 0;\n  }\n  hasRealInvoker = async () => {\n    const account = await this.getAccount();\n    return account.accountId() !== NULL_ACCOUNT;\n  };\n}\n/**\n * A transaction that has been sent to the Soroban network. This happens in two steps:\n *\n * 1. `sendTransaction`: initial submission of the transaction to the network.\n *    This step can run into problems, and will be retried with exponential\n *    backoff if it does. See all attempts in `sendTransactionResponseAll` and the\n *    most recent attempt in `sendTransactionResponse`.\n * 2. `getTransaction`: once the transaction has been submitted to the network\n *    successfully, you need to wait for it to finalize to get the results of the\n *    transaction. This step can also run into problems, and will be retried with\n *    exponential backoff if it does. See all attempts in\n *    `getTransactionResponseAll` and the most recent attempt in\n *    `getTransactionResponse`.\n */\nclass SentTransaction {\n  options;\n  assembled;\n  server;\n  signed;\n  sendTransactionResponse;\n  sendTransactionResponseAll;\n  getTransactionResponse;\n  getTransactionResponseAll;\n  constructor(options, assembled) {\n    this.options = options;\n    this.assembled = assembled;\n    this.server = new SorobanRpc.Server(this.options.rpcUrl, {\n      allowHttp: this.options.rpcUrl.startsWith(\"http://\")\n    });\n    this.assembled = assembled;\n  }\n  static init = async (options, assembled, secondsToWait = 10) => {\n    const tx = new SentTransaction(options, assembled);\n    return await tx.send(secondsToWait);\n  };\n  send = async (secondsToWait = 10) => {\n    const wallet = await this.assembled.getWallet();\n    this.sendTransactionResponseAll = await withExponentialBackoff(async previousFailure => {\n      if (previousFailure) {\n        // Increment transaction sequence number and resimulate before trying again\n        // Soroban transaction can only have 1 operation\n        const op = this.assembled.raw.operations[0];\n        this.assembled.raw = new TransactionBuilder(await this.assembled.getAccount(), {\n          fee: this.assembled.raw.fee,\n          networkPassphrase: this.options.networkPassphrase\n        }).setTimeout(TimeoutInfinite).addOperation(Operation.invokeHostFunction({\n          ...op,\n          auth: op.auth ?? []\n        })).build();\n        await this.assembled.simulate();\n      }\n      const signature = await wallet.signTransaction(this.assembled.raw.toXDR(), {\n        networkPassphrase: this.options.networkPassphrase\n      });\n      this.signed = TransactionBuilder.fromXDR(signature, this.options.networkPassphrase);\n      return this.server.sendTransaction(this.signed);\n    }, resp => resp.status !== \"PENDING\", secondsToWait);\n    this.sendTransactionResponse = this.sendTransactionResponseAll[this.sendTransactionResponseAll.length - 1];\n    if (this.sendTransactionResponse.status !== \"PENDING\") {\n      throw new Error(`Tried to resubmit transaction for ${secondsToWait} seconds, but it's still failing. ` + `All attempts: ${JSON.stringify(this.sendTransactionResponseAll, null, 2)}`);\n    }\n    const {\n      hash\n    } = this.sendTransactionResponse;\n    this.getTransactionResponseAll = await withExponentialBackoff(() => this.server.getTransaction(hash), resp => resp.status === SorobanRpc.Api.GetTransactionStatus.NOT_FOUND, secondsToWait);\n    this.getTransactionResponse = this.getTransactionResponseAll[this.getTransactionResponseAll.length - 1];\n    if (this.getTransactionResponse.status === SorobanRpc.Api.GetTransactionStatus.NOT_FOUND) {\n      console.error(`Waited ${secondsToWait} seconds for transaction to complete, but it did not. ` + `Returning anyway. Check the transaction status manually. ` + `Sent transaction: ${JSON.stringify(this.sendTransactionResponse, null, 2)}\\n` + `All attempts to get the result: ${JSON.stringify(this.getTransactionResponseAll, null, 2)}`);\n    }\n    return this;\n  };\n  get result() {\n    // 1. check if transaction was submitted and awaited with `getTransaction`\n    if (\"getTransactionResponse\" in this && this.getTransactionResponse) {\n      // getTransactionResponse has a `returnValue` field unless it failed\n      if (\"returnValue\" in this.getTransactionResponse) {\n        return this.options.parseResultXdr(this.getTransactionResponse.returnValue);\n      }\n      // if \"returnValue\" not present, the transaction failed; return without parsing the result\n      throw new Error(\"Transaction failed! Cannot parse result.\");\n    }\n    // 2. otherwise, maybe it was merely sent with `sendTransaction`\n    if (this.sendTransactionResponse) {\n      const errorResult = this.sendTransactionResponse.errorResult?.result();\n      if (errorResult) {\n        throw new SendFailedError(`Transaction simulation looked correct, but attempting to send the transaction failed. Check \\`simulation\\` and \\`sendTransactionResponseAll\\` to troubleshoot. Decoded \\`sendTransactionResponse.errorResultXdr\\`: ${errorResult}`);\n      }\n      throw new SendResultOnlyError(`Transaction was sent to the network, but not yet awaited. No result to show. Await transaction completion with \\`getTransaction(sendTransactionResponse.hash)\\``);\n    }\n    // 3. finally, if neither of those are present, throw an error\n    throw new Error(`Sending transaction failed: ${JSON.stringify(this.assembled)}`);\n  }\n}\n/**\n * Keep calling a `fn` for `secondsToWait` seconds, if `keepWaitingIf` is true.\n * Returns an array of all attempts to call the function.\n */\nasync function withExponentialBackoff(fn, keepWaitingIf, secondsToWait, exponentialFactor = 1.5, verbose = false) {\n  const attempts = [];\n  let count = 0;\n  attempts.push(await fn());\n  if (!keepWaitingIf(attempts[attempts.length - 1])) return attempts;\n  const waitUntil = new Date(Date.now() + secondsToWait * 1000).valueOf();\n  let waitTime = 1000;\n  let totalWaitTime = waitTime;\n  while (Date.now() < waitUntil && keepWaitingIf(attempts[attempts.length - 1])) {\n    count++;\n    // Wait a beat\n    if (verbose) {\n      console.info(`Waiting ${waitTime}ms before trying again (bringing the total wait time to ${totalWaitTime}ms so far, of total ${secondsToWait * 1000}ms)`);\n    }\n    await new Promise(res => setTimeout(res, waitTime));\n    // Exponential backoff\n    waitTime = waitTime * exponentialFactor;\n    if (new Date(Date.now() + waitTime).valueOf() > waitUntil) {\n      waitTime = waitUntil - Date.now();\n      if (verbose) {\n        console.info(`was gonna wait too long; new waitTime: ${waitTime}ms`);\n      }\n    }\n    totalWaitTime = waitTime + totalWaitTime;\n    // Try again\n    attempts.push(await fn(attempts[attempts.length - 1]));\n    if (verbose && keepWaitingIf(attempts[attempts.length - 1])) {\n      console.info(`${count}. Called ${fn}; ${attempts.length} prev attempts. Most recent: ${JSON.stringify(attempts[attempts.length - 1], null, 2)}`);\n    }\n  }\n  return attempts;\n}","map":{"version":3,"names":["Account","Address","Contract","Operation","SorobanRpc","StrKey","TimeoutInfinite","TransactionBuilder","authorizeEntry","hash","xdr","BASE_FEE","Buffer","ExpiredStateError","Error","NeedsMoreSignaturesError","WalletDisconnectedError","SendResultOnlyError","SendFailedError","NoUnsignedNonInvokerAuthEntriesError","Ok","value","constructor","unwrapErr","unwrap","isOk","isErr","Err","error","message","contractErrorPattern","NULL_ACCOUNT","AssembledTransaction","options","raw","simulation","simulationResult","simulationTransactionData","server","toJSON","JSON","stringify","method","tx","toXDR","auth","simulationData","result","map","a","retval","transactionData","fromJSON","txn","fromXDR","networkPassphrase","SorobanAuthorizationEntry","ScVal","SorobanTransactionData","Server","rpcUrl","allowHttp","startsWith","fromSimulation","contract","contractId","getAccount","fee","toString","addOperation","call","args","setTimeout","build","simulate","simulateTransaction","Api","isSimulationSuccess","assembleTransaction","isSimulationError","isSimulationRestore","parseResultXdr","e","err","parseError","errorMessage","errorTypes","match","i","parseInt","getWallet","wallet","default","getPublicKey","isConnected","isAllowed","getUserInfo","publicKey","signAndSend","secondsToWait","force","isReadCall","hasRealInvoker","source","accountId","needsNonInvokerSigningBy","length","SentTransaction","init","getStorageExpiration","key","getFootprint","expirationKey","LedgerKey","expiration","LedgerKeyExpiration","keyHash","entryRes","getLedgerEntries","entries","val","expirationLedgerSeq","includeAlreadySigned","rawInvokeHostFunctionOp","operations","Set","filter","entry","credentials","switch","SorobanCredentialsType","sorobanCredentialsAddress","address","signature","name","encodeEd25519PublicKey","ed25519","preImageFor","signatureExpirationLedger","addrAuth","HashIdPreimage","envelopeTypeSorobanAuthorization","HashIdPreimageSorobanAuthorization","networkId","from","nonce","invocation","rootInvocation","signAuthEntries","indexOf","authEntries","pk","preimage","signAuthEntry","authsCount","writeLength","resources","footprint","readWrite","account","assembled","signed","sendTransactionResponse","sendTransactionResponseAll","getTransactionResponse","getTransactionResponseAll","send","withExponentialBackoff","previousFailure","op","invokeHostFunction","signTransaction","sendTransaction","resp","status","getTransaction","GetTransactionStatus","NOT_FOUND","console","returnValue","errorResult","fn","keepWaitingIf","exponentialFactor","verbose","attempts","count","push","waitUntil","Date","now","valueOf","waitTime","totalWaitTime","info","Promise","res"],"sources":["/home/shubham/Desktop/seven-up-seven-down/node_modules/seven-up-seven-down/dist/esm/assembled-tx.js"],"sourcesContent":["import { Account, Address, Contract, Operation, SorobanRpc, StrKey, TimeoutInfinite, TransactionBuilder, authorizeEntry, hash, xdr, BASE_FEE, } from \"stellar-sdk\";\nimport { Buffer } from \"buffer\";\nexport class ExpiredStateError extends Error {\n}\nexport class NeedsMoreSignaturesError extends Error {\n}\nexport class WalletDisconnectedError extends Error {\n}\nexport class SendResultOnlyError extends Error {\n}\nexport class SendFailedError extends Error {\n}\nexport class NoUnsignedNonInvokerAuthEntriesError extends Error {\n}\nexport { Address };\n;\n;\nexport class Ok {\n    value;\n    constructor(value) {\n        this.value = value;\n    }\n    unwrapErr() {\n        throw new Error('No error');\n    }\n    unwrap() {\n        return this.value;\n    }\n    isOk() {\n        return true;\n    }\n    isErr() {\n        return !this.isOk();\n    }\n}\nexport class Err {\n    error;\n    constructor(error) {\n        this.error = error;\n    }\n    unwrapErr() {\n        return this.error;\n    }\n    unwrap() {\n        throw new Error(this.error.message);\n    }\n    isOk() {\n        return false;\n    }\n    isErr() {\n        return !this.isOk();\n    }\n}\nexport const contractErrorPattern = /Error\\(Contract, #(\\d+)\\)/;\nexport const NULL_ACCOUNT = \"GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF\";\nexport class AssembledTransaction {\n    options;\n    raw;\n    simulation;\n    simulationResult;\n    simulationTransactionData;\n    server;\n    toJSON() {\n        return JSON.stringify({\n            method: this.options.method,\n            tx: this.raw?.toXDR(),\n            simulationResult: {\n                auth: this.simulationData.result.auth.map(a => a.toXDR('base64')),\n                retval: this.simulationData.result.retval.toXDR('base64'),\n            },\n            simulationTransactionData: this.simulationData.transactionData.toXDR('base64'),\n        });\n    }\n    static fromJSON(options, { tx, simulationResult, simulationTransactionData }) {\n        const txn = new AssembledTransaction(options);\n        txn.raw = TransactionBuilder.fromXDR(tx, options.networkPassphrase);\n        txn.simulationResult = {\n            auth: simulationResult.auth.map(a => xdr.SorobanAuthorizationEntry.fromXDR(a, 'base64')),\n            retval: xdr.ScVal.fromXDR(simulationResult.retval, 'base64'),\n        };\n        txn.simulationTransactionData = xdr.SorobanTransactionData.fromXDR(simulationTransactionData, 'base64');\n        return txn;\n    }\n    constructor(options) {\n        this.options = options;\n        this.server = new SorobanRpc.Server(this.options.rpcUrl, {\n            allowHttp: this.options.rpcUrl.startsWith(\"http://\"),\n        });\n    }\n    static async fromSimulation(options) {\n        const tx = new AssembledTransaction(options);\n        const contract = new Contract(options.contractId);\n        tx.raw = new TransactionBuilder(await tx.getAccount(), {\n            fee: options.fee?.toString(10) ?? BASE_FEE,\n            networkPassphrase: options.networkPassphrase,\n        })\n            .addOperation(contract.call(options.method, ...(options.args ?? [])))\n            .setTimeout(TimeoutInfinite)\n            .build();\n        return await tx.simulate();\n    }\n    simulate = async () => {\n        if (!this.raw)\n            throw new Error('Transaction has not yet been assembled');\n        this.simulation = await this.server.simulateTransaction(this.raw);\n        if (SorobanRpc.Api.isSimulationSuccess(this.simulation)) {\n            this.raw = SorobanRpc.assembleTransaction(this.raw, this.simulation).build();\n        }\n        return this;\n    };\n    get simulationData() {\n        if (this.simulationResult && this.simulationTransactionData) {\n            return {\n                result: this.simulationResult,\n                transactionData: this.simulationTransactionData,\n            };\n        }\n        // else, we know we just did the simulation on this machine\n        const simulation = this.simulation;\n        if (SorobanRpc.Api.isSimulationError(simulation)) {\n            throw new Error(`Transaction simulation failed: \"${simulation.error}\"`);\n        }\n        if (SorobanRpc.Api.isSimulationRestore(simulation)) {\n            throw new ExpiredStateError(`You need to restore some contract state before you can invoke this method. ${JSON.stringify(simulation, null, 2)}`);\n        }\n        if (!simulation.result) {\n            throw new Error(`Expected an invocation simulation, but got no 'result' field. Simulation: ${JSON.stringify(simulation, null, 2)}`);\n        }\n        // add to object for serialization & deserialization\n        this.simulationResult = simulation.result;\n        this.simulationTransactionData = simulation.transactionData.build();\n        return {\n            result: this.simulationResult,\n            transactionData: this.simulationTransactionData,\n        };\n    }\n    get result() {\n        try {\n            return this.options.parseResultXdr(this.simulationData.result.retval);\n        }\n        catch (e) {\n            let err = this.parseError(e.toString());\n            if (err)\n                return err;\n            throw e;\n        }\n    }\n    parseError(errorMessage) {\n        if (!this.options.errorTypes)\n            return;\n        const match = errorMessage.match(contractErrorPattern);\n        if (!match)\n            return;\n        let i = parseInt(match[1], 10);\n        let err = this.options.errorTypes[i];\n        if (err)\n            return new Err(err);\n    }\n    getWallet = async () => {\n        return this.options.wallet ?? (await import(\"@stellar/freighter-api\")).default;\n    };\n    getPublicKey = async () => {\n        const wallet = await this.getWallet();\n        if (await wallet.isConnected() && await wallet.isAllowed()) {\n            return (await wallet.getUserInfo()).publicKey;\n        }\n    };\n    /**\n     * Get account details from the Soroban network for the publicKey currently\n     * selected in user's wallet. If not connected to Freighter, use placeholder\n     * null account.\n     */\n    getAccount = async () => {\n        const publicKey = await this.getPublicKey();\n        return publicKey\n            ? await this.server.getAccount(publicKey)\n            : new Account(NULL_ACCOUNT, \"0\");\n    };\n    /**\n     * Sign the transaction with the `wallet` (default Freighter), then send to\n     * the network and return a `SentTransaction` that keeps track of all the\n     * attempts to send and fetch the transaction from the network.\n     */\n    signAndSend = async ({ secondsToWait = 10, force = false } = {}) => {\n        if (!this.raw) {\n            throw new Error('Transaction has not yet been simulated');\n        }\n        if (!force && this.isReadCall) {\n            throw new Error('This is a read call. It requires no signature or sending. Use `force: true` to sign and send anyway.');\n        }\n        if (!await this.hasRealInvoker()) {\n            throw new WalletDisconnectedError('Wallet is not connected');\n        }\n        if (this.raw.source !== (await this.getAccount()).accountId()) {\n            throw new Error(`You must submit the transaction with the account that originally created it. Please switch to the wallet with \"${this.raw.source}\" as its public key.`);\n        }\n        if ((await this.needsNonInvokerSigningBy()).length) {\n            throw new NeedsMoreSignaturesError('Transaction requires more signatures. See `needsNonInvokerSigningBy` for details.');\n        }\n        return await SentTransaction.init(this.options, this, secondsToWait);\n    };\n    getStorageExpiration = async () => {\n        const key = new Contract(this.options.contractId).getFootprint()[1];\n        const expirationKey = xdr.LedgerKey.expiration(new xdr.LedgerKeyExpiration({ keyHash: hash(key.toXDR()) }));\n        const entryRes = await this.server.getLedgerEntries(expirationKey);\n        if (!(entryRes.entries && entryRes.entries.length))\n            throw new Error('failed to get ledger entry');\n        return entryRes.entries[0].val.expiration().expirationLedgerSeq();\n    };\n    /**\n     * Get a list of accounts, other than the invoker of the simulation, that\n     * need to sign auth entries in this transaction.\n     *\n     * Soroban allows multiple people to sign a transaction. Someone needs to\n     * sign the final transaction envelope; this person/account is called the\n     * _invoker_, or _source_. Other accounts might need to sign individual auth\n     * entries in the transaction, if they're not also the invoker.\n     *\n     * This function returns a list of accounts that need to sign auth entries,\n     * assuming that the same invoker/source account will sign the final\n     * transaction envelope as signed the initial simulation.\n     *\n     * One at a time, for each public key in this array, you will need to\n     * serialize this transaction with `toJSON`, send to the owner of that key,\n     * deserialize the transaction with `txFromJson`, and call\n     * {@link signAuthEntries}. Then re-serialize and send to the next account\n     * in this list.\n     */\n    needsNonInvokerSigningBy = async ({ includeAlreadySigned = false, } = {}) => {\n        if (!this.raw) {\n            throw new Error('Transaction has not yet been simulated');\n        }\n        // We expect that any transaction constructed by these libraries has a\n        // single operation, which is an InvokeHostFunction operation. The host\n        // function being invoked is the contract method call.\n        if (!(\"operations\" in this.raw)) {\n            throw new Error(`Unexpected Transaction type; no operations: ${JSON.stringify(this.raw)}`);\n        }\n        const rawInvokeHostFunctionOp = this.raw\n            .operations[0];\n        return [...new Set((rawInvokeHostFunctionOp.auth ?? []).filter(entry => entry.credentials().switch() ===\n                xdr.SorobanCredentialsType.sorobanCredentialsAddress() &&\n                (includeAlreadySigned ||\n                    entry.credentials().address().signature().switch().name === 'scvVoid')).map(entry => StrKey.encodeEd25519PublicKey(entry.credentials().address().address().accountId().ed25519())))];\n    };\n    preImageFor(entry, signatureExpirationLedger) {\n        const addrAuth = entry.credentials().address();\n        return xdr.HashIdPreimage.envelopeTypeSorobanAuthorization(new xdr.HashIdPreimageSorobanAuthorization({\n            networkId: hash(Buffer.from(this.options.networkPassphrase)),\n            nonce: addrAuth.nonce(),\n            invocation: entry.rootInvocation(),\n            signatureExpirationLedger,\n        }));\n    }\n    /**\n     * If {@link needsNonInvokerSigningBy} returns a non-empty list, you can serialize\n     * the transaction with `toJSON`, send it to the owner of one of the public keys\n     * in the map, deserialize with `txFromJSON`, and call this method on their\n     * machine. Internally, this will use `signAuthEntry` function from connected\n     * `wallet` for each.\n     *\n     * Then, re-serialize the transaction and either send to the next\n     * `needsNonInvokerSigningBy` owner, or send it back to the original account\n     * who simulated the transaction so they can {@link sign} the transaction\n     * envelope and {@link send} it to the network.\n     *\n     * Sending to all `needsNonInvokerSigningBy` owners in parallel is not currently\n     * supported!\n     */\n    signAuthEntries = async (\n    /**\n     * When to set each auth entry to expire. Could be any number of blocks in\n     * the future. Can be supplied as a promise or a raw number. Default:\n     * contract's current `persistent` storage expiration date/ledger\n     * number/block.\n     */\n    expiration = this.getStorageExpiration()) => {\n        if (!this.raw)\n            throw new Error('Transaction has not yet been assembled or simulated');\n        const needsNonInvokerSigningBy = await this.needsNonInvokerSigningBy();\n        if (!needsNonInvokerSigningBy)\n            throw new NoUnsignedNonInvokerAuthEntriesError('No unsigned non-invoker auth entries; maybe you already signed?');\n        const publicKey = await this.getPublicKey();\n        if (!publicKey)\n            throw new Error('Could not get public key from wallet; maybe Freighter is not signed in?');\n        if (needsNonInvokerSigningBy.indexOf(publicKey) === -1)\n            throw new Error(`No auth entries for public key \"${publicKey}\"`);\n        const wallet = await this.getWallet();\n        const rawInvokeHostFunctionOp = this.raw\n            .operations[0];\n        const authEntries = rawInvokeHostFunctionOp.auth ?? [];\n        for (const [i, entry] of authEntries.entries()) {\n            if (entry.credentials().switch() !==\n                xdr.SorobanCredentialsType.sorobanCredentialsAddress()) {\n                // if the invoker/source account, then the entry doesn't need explicit\n                // signature, since the tx envelope is already signed by the source\n                // account, so only check for sorobanCredentialsAddress\n                continue;\n            }\n            const pk = StrKey.encodeEd25519PublicKey(entry.credentials().address().address().accountId().ed25519());\n            // this auth entry needs to be signed by a different account\n            // (or maybe already was!)\n            if (pk !== publicKey)\n                continue;\n            authEntries[i] = await authorizeEntry(entry, async (preimage) => Buffer.from(await wallet.signAuthEntry(preimage.toXDR('base64')), 'base64'), await expiration, this.options.networkPassphrase);\n        }\n    };\n    get isReadCall() {\n        const authsCount = this.simulationData.result.auth.length;\n        const writeLength = this.simulationData.transactionData.resources().footprint().readWrite().length;\n        return (authsCount === 0) && (writeLength === 0);\n    }\n    hasRealInvoker = async () => {\n        const account = await this.getAccount();\n        return account.accountId() !== NULL_ACCOUNT;\n    };\n}\n/**\n * A transaction that has been sent to the Soroban network. This happens in two steps:\n *\n * 1. `sendTransaction`: initial submission of the transaction to the network.\n *    This step can run into problems, and will be retried with exponential\n *    backoff if it does. See all attempts in `sendTransactionResponseAll` and the\n *    most recent attempt in `sendTransactionResponse`.\n * 2. `getTransaction`: once the transaction has been submitted to the network\n *    successfully, you need to wait for it to finalize to get the results of the\n *    transaction. This step can also run into problems, and will be retried with\n *    exponential backoff if it does. See all attempts in\n *    `getTransactionResponseAll` and the most recent attempt in\n *    `getTransactionResponse`.\n */\nclass SentTransaction {\n    options;\n    assembled;\n    server;\n    signed;\n    sendTransactionResponse;\n    sendTransactionResponseAll;\n    getTransactionResponse;\n    getTransactionResponseAll;\n    constructor(options, assembled) {\n        this.options = options;\n        this.assembled = assembled;\n        this.server = new SorobanRpc.Server(this.options.rpcUrl, {\n            allowHttp: this.options.rpcUrl.startsWith(\"http://\"),\n        });\n        this.assembled = assembled;\n    }\n    static init = async (options, assembled, secondsToWait = 10) => {\n        const tx = new SentTransaction(options, assembled);\n        return await tx.send(secondsToWait);\n    };\n    send = async (secondsToWait = 10) => {\n        const wallet = await this.assembled.getWallet();\n        this.sendTransactionResponseAll = await withExponentialBackoff(async (previousFailure) => {\n            if (previousFailure) {\n                // Increment transaction sequence number and resimulate before trying again\n                // Soroban transaction can only have 1 operation\n                const op = this.assembled.raw.operations[0];\n                this.assembled.raw = new TransactionBuilder(await this.assembled.getAccount(), {\n                    fee: this.assembled.raw.fee,\n                    networkPassphrase: this.options.networkPassphrase,\n                })\n                    .setTimeout(TimeoutInfinite)\n                    .addOperation(Operation.invokeHostFunction({ ...op, auth: op.auth ?? [] }))\n                    .build();\n                await this.assembled.simulate();\n            }\n            const signature = await wallet.signTransaction(this.assembled.raw.toXDR(), {\n                networkPassphrase: this.options.networkPassphrase,\n            });\n            this.signed = TransactionBuilder.fromXDR(signature, this.options.networkPassphrase);\n            return this.server.sendTransaction(this.signed);\n        }, resp => resp.status !== \"PENDING\", secondsToWait);\n        this.sendTransactionResponse = this.sendTransactionResponseAll[this.sendTransactionResponseAll.length - 1];\n        if (this.sendTransactionResponse.status !== \"PENDING\") {\n            throw new Error(`Tried to resubmit transaction for ${secondsToWait} seconds, but it's still failing. ` +\n                `All attempts: ${JSON.stringify(this.sendTransactionResponseAll, null, 2)}`);\n        }\n        const { hash } = this.sendTransactionResponse;\n        this.getTransactionResponseAll = await withExponentialBackoff(() => this.server.getTransaction(hash), resp => resp.status === SorobanRpc.Api.GetTransactionStatus.NOT_FOUND, secondsToWait);\n        this.getTransactionResponse = this.getTransactionResponseAll[this.getTransactionResponseAll.length - 1];\n        if (this.getTransactionResponse.status === SorobanRpc.Api.GetTransactionStatus.NOT_FOUND) {\n            console.error(`Waited ${secondsToWait} seconds for transaction to complete, but it did not. ` +\n                `Returning anyway. Check the transaction status manually. ` +\n                `Sent transaction: ${JSON.stringify(this.sendTransactionResponse, null, 2)}\\n` +\n                `All attempts to get the result: ${JSON.stringify(this.getTransactionResponseAll, null, 2)}`);\n        }\n        return this;\n    };\n    get result() {\n        // 1. check if transaction was submitted and awaited with `getTransaction`\n        if (\"getTransactionResponse\" in this &&\n            this.getTransactionResponse) {\n            // getTransactionResponse has a `returnValue` field unless it failed\n            if (\"returnValue\" in this.getTransactionResponse) {\n                return this.options.parseResultXdr(this.getTransactionResponse.returnValue);\n            }\n            // if \"returnValue\" not present, the transaction failed; return without parsing the result\n            throw new Error(\"Transaction failed! Cannot parse result.\");\n        }\n        // 2. otherwise, maybe it was merely sent with `sendTransaction`\n        if (this.sendTransactionResponse) {\n            const errorResult = this.sendTransactionResponse.errorResult?.result();\n            if (errorResult) {\n                throw new SendFailedError(`Transaction simulation looked correct, but attempting to send the transaction failed. Check \\`simulation\\` and \\`sendTransactionResponseAll\\` to troubleshoot. Decoded \\`sendTransactionResponse.errorResultXdr\\`: ${errorResult}`);\n            }\n            throw new SendResultOnlyError(`Transaction was sent to the network, but not yet awaited. No result to show. Await transaction completion with \\`getTransaction(sendTransactionResponse.hash)\\``);\n        }\n        // 3. finally, if neither of those are present, throw an error\n        throw new Error(`Sending transaction failed: ${JSON.stringify(this.assembled)}`);\n    }\n}\n/**\n * Keep calling a `fn` for `secondsToWait` seconds, if `keepWaitingIf` is true.\n * Returns an array of all attempts to call the function.\n */\nasync function withExponentialBackoff(fn, keepWaitingIf, secondsToWait, exponentialFactor = 1.5, verbose = false) {\n    const attempts = [];\n    let count = 0;\n    attempts.push(await fn());\n    if (!keepWaitingIf(attempts[attempts.length - 1]))\n        return attempts;\n    const waitUntil = new Date(Date.now() + secondsToWait * 1000).valueOf();\n    let waitTime = 1000;\n    let totalWaitTime = waitTime;\n    while (Date.now() < waitUntil && keepWaitingIf(attempts[attempts.length - 1])) {\n        count++;\n        // Wait a beat\n        if (verbose) {\n            console.info(`Waiting ${waitTime}ms before trying again (bringing the total wait time to ${totalWaitTime}ms so far, of total ${secondsToWait * 1000}ms)`);\n        }\n        await new Promise(res => setTimeout(res, waitTime));\n        // Exponential backoff\n        waitTime = waitTime * exponentialFactor;\n        if (new Date(Date.now() + waitTime).valueOf() > waitUntil) {\n            waitTime = waitUntil - Date.now();\n            if (verbose) {\n                console.info(`was gonna wait too long; new waitTime: ${waitTime}ms`);\n            }\n        }\n        totalWaitTime = waitTime + totalWaitTime;\n        // Try again\n        attempts.push(await fn(attempts[attempts.length - 1]));\n        if (verbose && keepWaitingIf(attempts[attempts.length - 1])) {\n            console.info(`${count}. Called ${fn}; ${attempts.length} prev attempts. Most recent: ${JSON.stringify(attempts[attempts.length - 1], null, 2)}`);\n        }\n    }\n    return attempts;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}