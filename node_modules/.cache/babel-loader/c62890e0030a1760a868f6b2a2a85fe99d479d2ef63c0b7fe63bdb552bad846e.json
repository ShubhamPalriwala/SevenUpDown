{"ast":null,"code":"import { ContractSpec } from 'stellar-sdk';\nimport { Buffer } from \"buffer\";\nimport { AssembledTransaction } from './assembled-tx.js';\nexport * from './assembled-tx.js';\nexport * from './method-options.js';\nif (typeof window !== 'undefined') {\n  //@ts-ignore Buffer exists\n  window.Buffer = window.Buffer || Buffer;\n}\nexport const networks = {\n  futurenet: {\n    networkPassphrase: \"Test SDF Future Network ; October 2022\",\n    contractId: \"CAIBDMGVW3HS7HQMP7AOU3WRXCKLV7F7CBZXWXNMG3RDJ6PRCEO2V7K5\"\n  }\n};\n/**\n    \n    */\nexport const Errors = {};\nexport class Contract {\n  options;\n  spec;\n  constructor(options) {\n    this.options = options;\n    this.spec = new ContractSpec([\"AAAAAAAAAAAAAAAEcGxheQAAAAEAAAAAAAAACnByZWRpY3Rpb24AAAAAABEAAAABAAAD6gAAABE=\"]);\n  }\n  parsers = {\n    play: result => this.spec.funcResToNative(\"play\", result)\n  };\n  txFromJSON = json => {\n    const {\n      method,\n      ...tx\n    } = JSON.parse(json);\n    return AssembledTransaction.fromJSON({\n      ...this.options,\n      method,\n      parseResultXdr: this.parsers[method]\n    }, tx);\n  };\n  fromJSON = {\n    play: this.txFromJSON\n  };\n  /**\n  * Construct and simulate a play transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.\n  */\n  play = async ({\n    prediction\n  }, options = {}) => {\n    return await AssembledTransaction.fromSimulation({\n      method: 'play',\n      args: this.spec.funcArgsToScVals(\"play\", {\n        prediction\n      }),\n      ...options,\n      ...this.options,\n      errorTypes: Errors,\n      parseResultXdr: this.parsers['play']\n    });\n  };\n}","map":{"version":3,"names":["ContractSpec","Buffer","AssembledTransaction","window","networks","futurenet","networkPassphrase","contractId","Errors","Contract","options","spec","constructor","parsers","play","result","funcResToNative","txFromJSON","json","method","tx","JSON","parse","fromJSON","parseResultXdr","prediction","fromSimulation","args","funcArgsToScVals","errorTypes"],"sources":["/home/shubham/Desktop/seven-up-seven-down/node_modules/seven-up-seven-down/dist/esm/index.js"],"sourcesContent":["import { ContractSpec } from 'stellar-sdk';\nimport { Buffer } from \"buffer\";\nimport { AssembledTransaction } from './assembled-tx.js';\nexport * from './assembled-tx.js';\nexport * from './method-options.js';\nif (typeof window !== 'undefined') {\n    //@ts-ignore Buffer exists\n    window.Buffer = window.Buffer || Buffer;\n}\nexport const networks = {\n    futurenet: {\n        networkPassphrase: \"Test SDF Future Network ; October 2022\",\n        contractId: \"CAIBDMGVW3HS7HQMP7AOU3WRXCKLV7F7CBZXWXNMG3RDJ6PRCEO2V7K5\",\n    }\n};\n/**\n    \n    */\nexport const Errors = {};\nexport class Contract {\n    options;\n    spec;\n    constructor(options) {\n        this.options = options;\n        this.spec = new ContractSpec([\n            \"AAAAAAAAAAAAAAAEcGxheQAAAAEAAAAAAAAACnByZWRpY3Rpb24AAAAAABEAAAABAAAD6gAAABE=\"\n        ]);\n    }\n    parsers = {\n        play: (result) => this.spec.funcResToNative(\"play\", result)\n    };\n    txFromJSON = (json) => {\n        const { method, ...tx } = JSON.parse(json);\n        return AssembledTransaction.fromJSON({\n            ...this.options,\n            method,\n            parseResultXdr: this.parsers[method],\n        }, tx);\n    };\n    fromJSON = {\n        play: (this.txFromJSON)\n    };\n    /**\n* Construct and simulate a play transaction. Returns an `AssembledTransaction` object which will have a `result` field containing the result of the simulation. If this transaction changes contract state, you will need to call `signAndSend()` on the returned object.\n*/\n    play = async ({ prediction }, options = {}) => {\n        return await AssembledTransaction.fromSimulation({\n            method: 'play',\n            args: this.spec.funcArgsToScVals(\"play\", { prediction }),\n            ...options,\n            ...this.options,\n            errorTypes: Errors,\n            parseResultXdr: this.parsers['play'],\n        });\n    };\n}\n"],"mappings":"AAAA,SAASA,YAAY,QAAQ,aAAa;AAC1C,SAASC,MAAM,QAAQ,QAAQ;AAC/B,SAASC,oBAAoB,QAAQ,mBAAmB;AACxD,cAAc,mBAAmB;AACjC,cAAc,qBAAqB;AACnC,IAAI,OAAOC,MAAM,KAAK,WAAW,EAAE;EAC/B;EACAA,MAAM,CAACF,MAAM,GAAGE,MAAM,CAACF,MAAM,IAAIA,MAAM;AAC3C;AACA,OAAO,MAAMG,QAAQ,GAAG;EACpBC,SAAS,EAAE;IACPC,iBAAiB,EAAE,wCAAwC;IAC3DC,UAAU,EAAE;EAChB;AACJ,CAAC;AACD;AACA;AACA;AACA,OAAO,MAAMC,MAAM,GAAG,CAAC,CAAC;AACxB,OAAO,MAAMC,QAAQ,CAAC;EAClBC,OAAO;EACPC,IAAI;EACJC,WAAWA,CAACF,OAAO,EAAE;IACjB,IAAI,CAACA,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACC,IAAI,GAAG,IAAIX,YAAY,CAAC,CACzB,8EAA8E,CACjF,CAAC;EACN;EACAa,OAAO,GAAG;IACNC,IAAI,EAAGC,MAAM,IAAK,IAAI,CAACJ,IAAI,CAACK,eAAe,CAAC,MAAM,EAAED,MAAM;EAC9D,CAAC;EACDE,UAAU,GAAIC,IAAI,IAAK;IACnB,MAAM;MAAEC,MAAM;MAAE,GAAGC;IAAG,CAAC,GAAGC,IAAI,CAACC,KAAK,CAACJ,IAAI,CAAC;IAC1C,OAAOhB,oBAAoB,CAACqB,QAAQ,CAAC;MACjC,GAAG,IAAI,CAACb,OAAO;MACfS,MAAM;MACNK,cAAc,EAAE,IAAI,CAACX,OAAO,CAACM,MAAM;IACvC,CAAC,EAAEC,EAAE,CAAC;EACV,CAAC;EACDG,QAAQ,GAAG;IACPT,IAAI,EAAG,IAAI,CAACG;EAChB,CAAC;EACD;AACJ;AACA;EACIH,IAAI,GAAG,MAAAA,CAAO;IAAEW;EAAW,CAAC,EAAEf,OAAO,GAAG,CAAC,CAAC,KAAK;IAC3C,OAAO,MAAMR,oBAAoB,CAACwB,cAAc,CAAC;MAC7CP,MAAM,EAAE,MAAM;MACdQ,IAAI,EAAE,IAAI,CAAChB,IAAI,CAACiB,gBAAgB,CAAC,MAAM,EAAE;QAAEH;MAAW,CAAC,CAAC;MACxD,GAAGf,OAAO;MACV,GAAG,IAAI,CAACA,OAAO;MACfmB,UAAU,EAAErB,MAAM;MAClBgB,cAAc,EAAE,IAAI,CAACX,OAAO,CAAC,MAAM;IACvC,CAAC,CAAC;EACN,CAAC;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}