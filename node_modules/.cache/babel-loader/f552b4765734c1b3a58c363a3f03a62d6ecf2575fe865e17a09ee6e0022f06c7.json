{"ast":null,"code":"import _defineProperty from \"/home/shubham/Desktop/seven-up-seven-down/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nvar _class4;\nimport { Account, Address, Contract, Operation, SorobanRpc, StrKey, TimeoutInfinite, TransactionBuilder, authorizeEntry, hash, xdr, BASE_FEE } from \"stellar-sdk\";\nimport { Buffer } from \"buffer\";\nexport class ExpiredStateError extends Error {}\nexport class NeedsMoreSignaturesError extends Error {}\nexport class WalletDisconnectedError extends Error {}\nexport class SendResultOnlyError extends Error {}\nexport class SendFailedError extends Error {}\nexport class NoUnsignedNonInvokerAuthEntriesError extends Error {}\nexport { Address };\n;\n;\nexport class Ok {\n  constructor(value) {\n    _defineProperty(this, \"value\", void 0);\n    this.value = value;\n  }\n  unwrapErr() {\n    throw new Error('No error');\n  }\n  unwrap() {\n    return this.value;\n  }\n  isOk() {\n    return true;\n  }\n  isErr() {\n    return !this.isOk();\n  }\n}\nexport class Err {\n  constructor(error) {\n    _defineProperty(this, \"error\", void 0);\n    this.error = error;\n  }\n  unwrapErr() {\n    return this.error;\n  }\n  unwrap() {\n    throw new Error(this.error.message);\n  }\n  isOk() {\n    return false;\n  }\n  isErr() {\n    return !this.isOk();\n  }\n}\nexport const contractErrorPattern = /Error\\(Contract, #(\\d+)\\)/;\nexport const NULL_ACCOUNT = \"GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF\";\nexport class AssembledTransaction {\n  toJSON() {\n    var _this$raw;\n    return JSON.stringify({\n      method: this.options.method,\n      tx: (_this$raw = this.raw) === null || _this$raw === void 0 ? void 0 : _this$raw.toXDR(),\n      simulationResult: {\n        auth: this.simulationData.result.auth.map(a => a.toXDR('base64')),\n        retval: this.simulationData.result.retval.toXDR('base64')\n      },\n      simulationTransactionData: this.simulationData.transactionData.toXDR('base64')\n    });\n  }\n  static fromJSON(options, _ref) {\n    let {\n      tx,\n      simulationResult,\n      simulationTransactionData\n    } = _ref;\n    const txn = new AssembledTransaction(options);\n    txn.raw = TransactionBuilder.fromXDR(tx, options.networkPassphrase);\n    txn.simulationResult = {\n      auth: simulationResult.auth.map(a => xdr.SorobanAuthorizationEntry.fromXDR(a, 'base64')),\n      retval: xdr.ScVal.fromXDR(simulationResult.retval, 'base64')\n    };\n    txn.simulationTransactionData = xdr.SorobanTransactionData.fromXDR(simulationTransactionData, 'base64');\n    return txn;\n  }\n  constructor(options) {\n    var _this = this;\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"raw\", void 0);\n    _defineProperty(this, \"simulation\", void 0);\n    _defineProperty(this, \"simulationResult\", void 0);\n    _defineProperty(this, \"simulationTransactionData\", void 0);\n    _defineProperty(this, \"server\", void 0);\n    _defineProperty(this, \"simulate\", async () => {\n      if (!this.raw) throw new Error('Transaction has not yet been assembled');\n      this.simulation = await this.server.simulateTransaction(this.raw);\n      if (SorobanRpc.Api.isSimulationSuccess(this.simulation)) {\n        this.raw = SorobanRpc.assembleTransaction(this.raw, this.simulation).build();\n      }\n      return this;\n    });\n    _defineProperty(this, \"getWallet\", async () => {\n      var _this$options$wallet;\n      return (_this$options$wallet = this.options.wallet) !== null && _this$options$wallet !== void 0 ? _this$options$wallet : (await import(\"@stellar/freighter-api\")).default;\n    });\n    _defineProperty(this, \"getPublicKey\", async () => {\n      const wallet = await this.getWallet();\n      if ((await wallet.isConnected()) && (await wallet.isAllowed())) {\n        return (await wallet.getUserInfo()).publicKey;\n      }\n    });\n    /**\n     * Get account details from the Soroban network for the publicKey currently\n     * selected in user's wallet. If not connected to Freighter, use placeholder\n     * null account.\n     */\n    _defineProperty(this, \"getAccount\", async () => {\n      const publicKey = await this.getPublicKey();\n      return publicKey ? await this.server.getAccount(publicKey) : new Account(NULL_ACCOUNT, \"0\");\n    });\n    /**\n     * Sign the transaction with the `wallet` (default Freighter), then send to\n     * the network and return a `SentTransaction` that keeps track of all the\n     * attempts to send and fetch the transaction from the network.\n     */\n    _defineProperty(this, \"signAndSend\", async function () {\n      let {\n        secondsToWait = 10,\n        force = false\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (!_this.raw) {\n        throw new Error('Transaction has not yet been simulated');\n      }\n      if (!force && _this.isReadCall) {\n        throw new Error('This is a read call. It requires no signature or sending. Use `force: true` to sign and send anyway.');\n      }\n      if (!(await _this.hasRealInvoker())) {\n        throw new WalletDisconnectedError('Wallet is not connected');\n      }\n      if (_this.raw.source !== (await _this.getAccount()).accountId()) {\n        throw new Error(\"You must submit the transaction with the account that originally created it. Please switch to the wallet with \\\"\".concat(_this.raw.source, \"\\\" as its public key.\"));\n      }\n      if ((await _this.needsNonInvokerSigningBy()).length) {\n        throw new NeedsMoreSignaturesError('Transaction requires more signatures. See `needsNonInvokerSigningBy` for details.');\n      }\n      return await SentTransaction.init(_this.options, _this, secondsToWait);\n    });\n    _defineProperty(this, \"getStorageExpiration\", async () => {\n      const key = new Contract(this.options.contractId).getFootprint()[1];\n      const expirationKey = xdr.LedgerKey.expiration(new xdr.LedgerKeyExpiration({\n        keyHash: hash(key.toXDR())\n      }));\n      const entryRes = await this.server.getLedgerEntries(expirationKey);\n      if (!(entryRes.entries && entryRes.entries.length)) throw new Error('failed to get ledger entry');\n      return entryRes.entries[0].val.expiration().expirationLedgerSeq();\n    });\n    /**\n     * Get a list of accounts, other than the invoker of the simulation, that\n     * need to sign auth entries in this transaction.\n     *\n     * Soroban allows multiple people to sign a transaction. Someone needs to\n     * sign the final transaction envelope; this person/account is called the\n     * _invoker_, or _source_. Other accounts might need to sign individual auth\n     * entries in the transaction, if they're not also the invoker.\n     *\n     * This function returns a list of accounts that need to sign auth entries,\n     * assuming that the same invoker/source account will sign the final\n     * transaction envelope as signed the initial simulation.\n     *\n     * One at a time, for each public key in this array, you will need to\n     * serialize this transaction with `toJSON`, send to the owner of that key,\n     * deserialize the transaction with `txFromJson`, and call\n     * {@link signAuthEntries}. Then re-serialize and send to the next account\n     * in this list.\n     */\n    _defineProperty(this, \"needsNonInvokerSigningBy\", async function () {\n      var _rawInvokeHostFunctio;\n      let {\n        includeAlreadySigned = false\n      } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (!_this.raw) {\n        throw new Error('Transaction has not yet been simulated');\n      }\n      // We expect that any transaction constructed by these libraries has a\n      // single operation, which is an InvokeHostFunction operation. The host\n      // function being invoked is the contract method call.\n      if (!(\"operations\" in _this.raw)) {\n        throw new Error(\"Unexpected Transaction type; no operations: \".concat(JSON.stringify(_this.raw)));\n      }\n      const rawInvokeHostFunctionOp = _this.raw.operations[0];\n      return [...new Set(((_rawInvokeHostFunctio = rawInvokeHostFunctionOp.auth) !== null && _rawInvokeHostFunctio !== void 0 ? _rawInvokeHostFunctio : []).filter(entry => entry.credentials().switch() === xdr.SorobanCredentialsType.sorobanCredentialsAddress() && (includeAlreadySigned || entry.credentials().address().signature().switch().name === 'scvVoid')).map(entry => StrKey.encodeEd25519PublicKey(entry.credentials().address().address().accountId().ed25519())))];\n    });\n    /**\n     * If {@link needsNonInvokerSigningBy} returns a non-empty list, you can serialize\n     * the transaction with `toJSON`, send it to the owner of one of the public keys\n     * in the map, deserialize with `txFromJSON`, and call this method on their\n     * machine. Internally, this will use `signAuthEntry` function from connected\n     * `wallet` for each.\n     *\n     * Then, re-serialize the transaction and either send to the next\n     * `needsNonInvokerSigningBy` owner, or send it back to the original account\n     * who simulated the transaction so they can {@link sign} the transaction\n     * envelope and {@link send} it to the network.\n     *\n     * Sending to all `needsNonInvokerSigningBy` owners in parallel is not currently\n     * supported!\n     */\n    _defineProperty(this, \"signAuthEntries\", async function () {\n      var _rawInvokeHostFunctio2;\n      let expiration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.getStorageExpiration();\n      if (!_this.raw) throw new Error('Transaction has not yet been assembled or simulated');\n      const needsNonInvokerSigningBy = await _this.needsNonInvokerSigningBy();\n      if (!needsNonInvokerSigningBy) throw new NoUnsignedNonInvokerAuthEntriesError('No unsigned non-invoker auth entries; maybe you already signed?');\n      const publicKey = await _this.getPublicKey();\n      if (!publicKey) throw new Error('Could not get public key from wallet; maybe Freighter is not signed in?');\n      if (needsNonInvokerSigningBy.indexOf(publicKey) === -1) throw new Error(\"No auth entries for public key \\\"\".concat(publicKey, \"\\\"\"));\n      const wallet = await _this.getWallet();\n      const rawInvokeHostFunctionOp = _this.raw.operations[0];\n      const authEntries = (_rawInvokeHostFunctio2 = rawInvokeHostFunctionOp.auth) !== null && _rawInvokeHostFunctio2 !== void 0 ? _rawInvokeHostFunctio2 : [];\n      for (const [i, entry] of authEntries.entries()) {\n        if (entry.credentials().switch() !== xdr.SorobanCredentialsType.sorobanCredentialsAddress()) {\n          // if the invoker/source account, then the entry doesn't need explicit\n          // signature, since the tx envelope is already signed by the source\n          // account, so only check for sorobanCredentialsAddress\n          continue;\n        }\n        const pk = StrKey.encodeEd25519PublicKey(entry.credentials().address().address().accountId().ed25519());\n        // this auth entry needs to be signed by a different account\n        // (or maybe already was!)\n        if (pk !== publicKey) continue;\n        authEntries[i] = await authorizeEntry(entry, async preimage => Buffer.from(await wallet.signAuthEntry(preimage.toXDR('base64')), 'base64'), await expiration, _this.options.networkPassphrase);\n      }\n    });\n    _defineProperty(this, \"hasRealInvoker\", async () => {\n      const account = await this.getAccount();\n      return account.accountId() !== NULL_ACCOUNT;\n    });\n    this.options = options;\n    this.server = new SorobanRpc.Server(this.options.rpcUrl, {\n      allowHttp: this.options.rpcUrl.startsWith(\"http://\")\n    });\n  }\n  static async fromSimulation(options) {\n    var _options$fee$toString, _options$fee, _options$args;\n    const tx = new AssembledTransaction(options);\n    const contract = new Contract(options.contractId);\n    tx.raw = new TransactionBuilder(await tx.getAccount(), {\n      fee: (_options$fee$toString = (_options$fee = options.fee) === null || _options$fee === void 0 ? void 0 : _options$fee.toString(10)) !== null && _options$fee$toString !== void 0 ? _options$fee$toString : BASE_FEE,\n      networkPassphrase: options.networkPassphrase\n    }).addOperation(contract.call(options.method, ...((_options$args = options.args) !== null && _options$args !== void 0 ? _options$args : []))).setTimeout(TimeoutInfinite).build();\n    return await tx.simulate();\n  }\n  get simulationData() {\n    if (this.simulationResult && this.simulationTransactionData) {\n      return {\n        result: this.simulationResult,\n        transactionData: this.simulationTransactionData\n      };\n    }\n    // else, we know we just did the simulation on this machine\n    const simulation = this.simulation;\n    if (SorobanRpc.Api.isSimulationError(simulation)) {\n      throw new Error(\"Transaction simulation failed: \\\"\".concat(simulation.error, \"\\\"\"));\n    }\n    if (SorobanRpc.Api.isSimulationRestore(simulation)) {\n      throw new ExpiredStateError(\"You need to restore some contract state before you can invoke this method. \".concat(JSON.stringify(simulation, null, 2)));\n    }\n    if (!simulation.result) {\n      throw new Error(\"Expected an invocation simulation, but got no 'result' field. Simulation: \".concat(JSON.stringify(simulation, null, 2)));\n    }\n    // add to object for serialization & deserialization\n    this.simulationResult = simulation.result;\n    this.simulationTransactionData = simulation.transactionData.build();\n    return {\n      result: this.simulationResult,\n      transactionData: this.simulationTransactionData\n    };\n  }\n  get result() {\n    try {\n      return this.options.parseResultXdr(this.simulationData.result.retval);\n    } catch (e) {\n      let err = this.parseError(e.toString());\n      if (err) return err;\n      throw e;\n    }\n  }\n  parseError(errorMessage) {\n    if (!this.options.errorTypes) return;\n    const match = errorMessage.match(contractErrorPattern);\n    if (!match) return;\n    let i = parseInt(match[1], 10);\n    let err = this.options.errorTypes[i];\n    if (err) return new Err(err);\n  }\n  preImageFor(entry, signatureExpirationLedger) {\n    const addrAuth = entry.credentials().address();\n    return xdr.HashIdPreimage.envelopeTypeSorobanAuthorization(new xdr.HashIdPreimageSorobanAuthorization({\n      networkId: hash(Buffer.from(this.options.networkPassphrase)),\n      nonce: addrAuth.nonce(),\n      invocation: entry.rootInvocation(),\n      signatureExpirationLedger\n    }));\n  }\n  get isReadCall() {\n    const authsCount = this.simulationData.result.auth.length;\n    const writeLength = this.simulationData.transactionData.resources().footprint().readWrite().length;\n    return authsCount === 0 && writeLength === 0;\n  }\n}\n/**\n * A transaction that has been sent to the Soroban network. This happens in two steps:\n *\n * 1. `sendTransaction`: initial submission of the transaction to the network.\n *    This step can run into problems, and will be retried with exponential\n *    backoff if it does. See all attempts in `sendTransactionResponseAll` and the\n *    most recent attempt in `sendTransactionResponse`.\n * 2. `getTransaction`: once the transaction has been submitted to the network\n *    successfully, you need to wait for it to finalize to get the results of the\n *    transaction. This step can also run into problems, and will be retried with\n *    exponential backoff if it does. See all attempts in\n *    `getTransactionResponseAll` and the most recent attempt in\n *    `getTransactionResponse`.\n */\nclass SentTransaction {\n  constructor(options, assembled) {\n    var _this2 = this;\n    _defineProperty(this, \"options\", void 0);\n    _defineProperty(this, \"assembled\", void 0);\n    _defineProperty(this, \"server\", void 0);\n    _defineProperty(this, \"signed\", void 0);\n    _defineProperty(this, \"sendTransactionResponse\", void 0);\n    _defineProperty(this, \"sendTransactionResponseAll\", void 0);\n    _defineProperty(this, \"getTransactionResponse\", void 0);\n    _defineProperty(this, \"getTransactionResponseAll\", void 0);\n    _defineProperty(this, \"send\", async function () {\n      let secondsToWait = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n      const wallet = await _this2.assembled.getWallet();\n      _this2.sendTransactionResponseAll = await withExponentialBackoff(async previousFailure => {\n        if (previousFailure) {\n          var _op$auth;\n          // Increment transaction sequence number and resimulate before trying again\n          // Soroban transaction can only have 1 operation\n          const op = _this2.assembled.raw.operations[0];\n          _this2.assembled.raw = new TransactionBuilder(await _this2.assembled.getAccount(), {\n            fee: _this2.assembled.raw.fee,\n            networkPassphrase: _this2.options.networkPassphrase\n          }).setTimeout(TimeoutInfinite).addOperation(Operation.invokeHostFunction({\n            ...op,\n            auth: (_op$auth = op.auth) !== null && _op$auth !== void 0 ? _op$auth : []\n          })).build();\n          await _this2.assembled.simulate();\n        }\n        const signature = await wallet.signTransaction(_this2.assembled.raw.toXDR(), {\n          networkPassphrase: _this2.options.networkPassphrase\n        });\n        _this2.signed = TransactionBuilder.fromXDR(signature, _this2.options.networkPassphrase);\n        return _this2.server.sendTransaction(_this2.signed);\n      }, resp => resp.status !== \"PENDING\", secondsToWait);\n      _this2.sendTransactionResponse = _this2.sendTransactionResponseAll[_this2.sendTransactionResponseAll.length - 1];\n      if (_this2.sendTransactionResponse.status !== \"PENDING\") {\n        throw new Error(\"Tried to resubmit transaction for \".concat(secondsToWait, \" seconds, but it's still failing. \") + \"All attempts: \".concat(JSON.stringify(_this2.sendTransactionResponseAll, null, 2)));\n      }\n      const {\n        hash\n      } = _this2.sendTransactionResponse;\n      _this2.getTransactionResponseAll = await withExponentialBackoff(() => _this2.server.getTransaction(hash), resp => resp.status === SorobanRpc.Api.GetTransactionStatus.NOT_FOUND, secondsToWait);\n      _this2.getTransactionResponse = _this2.getTransactionResponseAll[_this2.getTransactionResponseAll.length - 1];\n      if (_this2.getTransactionResponse.status === SorobanRpc.Api.GetTransactionStatus.NOT_FOUND) {\n        console.error(\"Waited \".concat(secondsToWait, \" seconds for transaction to complete, but it did not. \") + \"Returning anyway. Check the transaction status manually. \" + \"Sent transaction: \".concat(JSON.stringify(_this2.sendTransactionResponse, null, 2), \"\\n\") + \"All attempts to get the result: \".concat(JSON.stringify(_this2.getTransactionResponseAll, null, 2)));\n      }\n      return _this2;\n    });\n    this.options = options;\n    this.assembled = assembled;\n    this.server = new SorobanRpc.Server(this.options.rpcUrl, {\n      allowHttp: this.options.rpcUrl.startsWith(\"http://\")\n    });\n    this.assembled = assembled;\n  }\n  get result() {\n    // 1. check if transaction was submitted and awaited with `getTransaction`\n    if (\"getTransactionResponse\" in this && this.getTransactionResponse) {\n      // getTransactionResponse has a `returnValue` field unless it failed\n      if (\"returnValue\" in this.getTransactionResponse) {\n        return this.options.parseResultXdr(this.getTransactionResponse.returnValue);\n      }\n      // if \"returnValue\" not present, the transaction failed; return without parsing the result\n      throw new Error(\"Transaction failed! Cannot parse result.\");\n    }\n    // 2. otherwise, maybe it was merely sent with `sendTransaction`\n    if (this.sendTransactionResponse) {\n      var _this$sendTransaction;\n      const errorResult = (_this$sendTransaction = this.sendTransactionResponse.errorResult) === null || _this$sendTransaction === void 0 ? void 0 : _this$sendTransaction.result();\n      if (errorResult) {\n        throw new SendFailedError(\"Transaction simulation looked correct, but attempting to send the transaction failed. Check `simulation` and `sendTransactionResponseAll` to troubleshoot. Decoded `sendTransactionResponse.errorResultXdr`: \".concat(errorResult));\n      }\n      throw new SendResultOnlyError(\"Transaction was sent to the network, but not yet awaited. No result to show. Await transaction completion with `getTransaction(sendTransactionResponse.hash)`\");\n    }\n    // 3. finally, if neither of those are present, throw an error\n    throw new Error(\"Sending transaction failed: \".concat(JSON.stringify(this.assembled)));\n  }\n}\n/**\n * Keep calling a `fn` for `secondsToWait` seconds, if `keepWaitingIf` is true.\n * Returns an array of all attempts to call the function.\n */\n_class4 = SentTransaction;\n_defineProperty(SentTransaction, \"init\", async function (options, assembled) {\n  let secondsToWait = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;\n  const tx = new _class4(options, assembled);\n  return await tx.send(secondsToWait);\n});\nasync function withExponentialBackoff(fn, keepWaitingIf, secondsToWait) {\n  let exponentialFactor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1.5;\n  let verbose = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  const attempts = [];\n  let count = 0;\n  attempts.push(await fn());\n  if (!keepWaitingIf(attempts[attempts.length - 1])) return attempts;\n  const waitUntil = new Date(Date.now() + secondsToWait * 1000).valueOf();\n  let waitTime = 1000;\n  let totalWaitTime = waitTime;\n  while (Date.now() < waitUntil && keepWaitingIf(attempts[attempts.length - 1])) {\n    count++;\n    // Wait a beat\n    if (verbose) {\n      console.info(\"Waiting \".concat(waitTime, \"ms before trying again (bringing the total wait time to \").concat(totalWaitTime, \"ms so far, of total \").concat(secondsToWait * 1000, \"ms)\"));\n    }\n    await new Promise(res => setTimeout(res, waitTime));\n    // Exponential backoff\n    waitTime = waitTime * exponentialFactor;\n    if (new Date(Date.now() + waitTime).valueOf() > waitUntil) {\n      waitTime = waitUntil - Date.now();\n      if (verbose) {\n        console.info(\"was gonna wait too long; new waitTime: \".concat(waitTime, \"ms\"));\n      }\n    }\n    totalWaitTime = waitTime + totalWaitTime;\n    // Try again\n    attempts.push(await fn(attempts[attempts.length - 1]));\n    if (verbose && keepWaitingIf(attempts[attempts.length - 1])) {\n      console.info(\"\".concat(count, \". Called \").concat(fn, \"; \").concat(attempts.length, \" prev attempts. Most recent: \").concat(JSON.stringify(attempts[attempts.length - 1], null, 2)));\n    }\n  }\n  return attempts;\n}","map":{"version":3,"names":["Account","Address","Contract","Operation","SorobanRpc","StrKey","TimeoutInfinite","TransactionBuilder","authorizeEntry","hash","xdr","BASE_FEE","Buffer","ExpiredStateError","Error","NeedsMoreSignaturesError","WalletDisconnectedError","SendResultOnlyError","SendFailedError","NoUnsignedNonInvokerAuthEntriesError","Ok","constructor","value","_defineProperty","unwrapErr","unwrap","isOk","isErr","Err","error","message","contractErrorPattern","NULL_ACCOUNT","AssembledTransaction","toJSON","_this$raw","JSON","stringify","method","options","tx","raw","toXDR","simulationResult","auth","simulationData","result","map","a","retval","simulationTransactionData","transactionData","fromJSON","_ref","txn","fromXDR","networkPassphrase","SorobanAuthorizationEntry","ScVal","SorobanTransactionData","_this","simulation","server","simulateTransaction","Api","isSimulationSuccess","assembleTransaction","build","_this$options$wallet","wallet","default","getWallet","isConnected","isAllowed","getUserInfo","publicKey","getPublicKey","getAccount","secondsToWait","force","arguments","length","undefined","isReadCall","hasRealInvoker","source","accountId","concat","needsNonInvokerSigningBy","SentTransaction","init","key","contractId","getFootprint","expirationKey","LedgerKey","expiration","LedgerKeyExpiration","keyHash","entryRes","getLedgerEntries","entries","val","expirationLedgerSeq","_rawInvokeHostFunctio","includeAlreadySigned","rawInvokeHostFunctionOp","operations","Set","filter","entry","credentials","switch","SorobanCredentialsType","sorobanCredentialsAddress","address","signature","name","encodeEd25519PublicKey","ed25519","_rawInvokeHostFunctio2","getStorageExpiration","indexOf","authEntries","i","pk","preimage","from","signAuthEntry","account","Server","rpcUrl","allowHttp","startsWith","fromSimulation","_options$fee$toString","_options$fee","_options$args","contract","fee","toString","addOperation","call","args","setTimeout","simulate","isSimulationError","isSimulationRestore","parseResultXdr","e","err","parseError","errorMessage","errorTypes","match","parseInt","preImageFor","signatureExpirationLedger","addrAuth","HashIdPreimage","envelopeTypeSorobanAuthorization","HashIdPreimageSorobanAuthorization","networkId","nonce","invocation","rootInvocation","authsCount","writeLength","resources","footprint","readWrite","assembled","_this2","sendTransactionResponseAll","withExponentialBackoff","previousFailure","_op$auth","op","invokeHostFunction","signTransaction","signed","sendTransaction","resp","status","sendTransactionResponse","getTransactionResponseAll","getTransaction","GetTransactionStatus","NOT_FOUND","getTransactionResponse","console","returnValue","_this$sendTransaction","errorResult","_class4","send","fn","keepWaitingIf","exponentialFactor","verbose","attempts","count","push","waitUntil","Date","now","valueOf","waitTime","totalWaitTime","info","Promise","res"],"sources":["/home/shubham/Desktop/seven-up-seven-down/node_modules/seven-up-seven-down/dist/esm/assembled-tx.js"],"sourcesContent":["import { Account, Address, Contract, Operation, SorobanRpc, StrKey, TimeoutInfinite, TransactionBuilder, authorizeEntry, hash, xdr, BASE_FEE, } from \"stellar-sdk\";\nimport { Buffer } from \"buffer\";\nexport class ExpiredStateError extends Error {\n}\nexport class NeedsMoreSignaturesError extends Error {\n}\nexport class WalletDisconnectedError extends Error {\n}\nexport class SendResultOnlyError extends Error {\n}\nexport class SendFailedError extends Error {\n}\nexport class NoUnsignedNonInvokerAuthEntriesError extends Error {\n}\nexport { Address };\n;\n;\nexport class Ok {\n    value;\n    constructor(value) {\n        this.value = value;\n    }\n    unwrapErr() {\n        throw new Error('No error');\n    }\n    unwrap() {\n        return this.value;\n    }\n    isOk() {\n        return true;\n    }\n    isErr() {\n        return !this.isOk();\n    }\n}\nexport class Err {\n    error;\n    constructor(error) {\n        this.error = error;\n    }\n    unwrapErr() {\n        return this.error;\n    }\n    unwrap() {\n        throw new Error(this.error.message);\n    }\n    isOk() {\n        return false;\n    }\n    isErr() {\n        return !this.isOk();\n    }\n}\nexport const contractErrorPattern = /Error\\(Contract, #(\\d+)\\)/;\nexport const NULL_ACCOUNT = \"GAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWHF\";\nexport class AssembledTransaction {\n    options;\n    raw;\n    simulation;\n    simulationResult;\n    simulationTransactionData;\n    server;\n    toJSON() {\n        return JSON.stringify({\n            method: this.options.method,\n            tx: this.raw?.toXDR(),\n            simulationResult: {\n                auth: this.simulationData.result.auth.map(a => a.toXDR('base64')),\n                retval: this.simulationData.result.retval.toXDR('base64'),\n            },\n            simulationTransactionData: this.simulationData.transactionData.toXDR('base64'),\n        });\n    }\n    static fromJSON(options, { tx, simulationResult, simulationTransactionData }) {\n        const txn = new AssembledTransaction(options);\n        txn.raw = TransactionBuilder.fromXDR(tx, options.networkPassphrase);\n        txn.simulationResult = {\n            auth: simulationResult.auth.map(a => xdr.SorobanAuthorizationEntry.fromXDR(a, 'base64')),\n            retval: xdr.ScVal.fromXDR(simulationResult.retval, 'base64'),\n        };\n        txn.simulationTransactionData = xdr.SorobanTransactionData.fromXDR(simulationTransactionData, 'base64');\n        return txn;\n    }\n    constructor(options) {\n        this.options = options;\n        this.server = new SorobanRpc.Server(this.options.rpcUrl, {\n            allowHttp: this.options.rpcUrl.startsWith(\"http://\"),\n        });\n    }\n    static async fromSimulation(options) {\n        const tx = new AssembledTransaction(options);\n        const contract = new Contract(options.contractId);\n        tx.raw = new TransactionBuilder(await tx.getAccount(), {\n            fee: options.fee?.toString(10) ?? BASE_FEE,\n            networkPassphrase: options.networkPassphrase,\n        })\n            .addOperation(contract.call(options.method, ...(options.args ?? [])))\n            .setTimeout(TimeoutInfinite)\n            .build();\n        return await tx.simulate();\n    }\n    simulate = async () => {\n        if (!this.raw)\n            throw new Error('Transaction has not yet been assembled');\n        this.simulation = await this.server.simulateTransaction(this.raw);\n        if (SorobanRpc.Api.isSimulationSuccess(this.simulation)) {\n            this.raw = SorobanRpc.assembleTransaction(this.raw, this.simulation).build();\n        }\n        return this;\n    };\n    get simulationData() {\n        if (this.simulationResult && this.simulationTransactionData) {\n            return {\n                result: this.simulationResult,\n                transactionData: this.simulationTransactionData,\n            };\n        }\n        // else, we know we just did the simulation on this machine\n        const simulation = this.simulation;\n        if (SorobanRpc.Api.isSimulationError(simulation)) {\n            throw new Error(`Transaction simulation failed: \"${simulation.error}\"`);\n        }\n        if (SorobanRpc.Api.isSimulationRestore(simulation)) {\n            throw new ExpiredStateError(`You need to restore some contract state before you can invoke this method. ${JSON.stringify(simulation, null, 2)}`);\n        }\n        if (!simulation.result) {\n            throw new Error(`Expected an invocation simulation, but got no 'result' field. Simulation: ${JSON.stringify(simulation, null, 2)}`);\n        }\n        // add to object for serialization & deserialization\n        this.simulationResult = simulation.result;\n        this.simulationTransactionData = simulation.transactionData.build();\n        return {\n            result: this.simulationResult,\n            transactionData: this.simulationTransactionData,\n        };\n    }\n    get result() {\n        try {\n            return this.options.parseResultXdr(this.simulationData.result.retval);\n        }\n        catch (e) {\n            let err = this.parseError(e.toString());\n            if (err)\n                return err;\n            throw e;\n        }\n    }\n    parseError(errorMessage) {\n        if (!this.options.errorTypes)\n            return;\n        const match = errorMessage.match(contractErrorPattern);\n        if (!match)\n            return;\n        let i = parseInt(match[1], 10);\n        let err = this.options.errorTypes[i];\n        if (err)\n            return new Err(err);\n    }\n    getWallet = async () => {\n        return this.options.wallet ?? (await import(\"@stellar/freighter-api\")).default;\n    };\n    getPublicKey = async () => {\n        const wallet = await this.getWallet();\n        if (await wallet.isConnected() && await wallet.isAllowed()) {\n            return (await wallet.getUserInfo()).publicKey;\n        }\n    };\n    /**\n     * Get account details from the Soroban network for the publicKey currently\n     * selected in user's wallet. If not connected to Freighter, use placeholder\n     * null account.\n     */\n    getAccount = async () => {\n        const publicKey = await this.getPublicKey();\n        return publicKey\n            ? await this.server.getAccount(publicKey)\n            : new Account(NULL_ACCOUNT, \"0\");\n    };\n    /**\n     * Sign the transaction with the `wallet` (default Freighter), then send to\n     * the network and return a `SentTransaction` that keeps track of all the\n     * attempts to send and fetch the transaction from the network.\n     */\n    signAndSend = async ({ secondsToWait = 10, force = false } = {}) => {\n        if (!this.raw) {\n            throw new Error('Transaction has not yet been simulated');\n        }\n        if (!force && this.isReadCall) {\n            throw new Error('This is a read call. It requires no signature or sending. Use `force: true` to sign and send anyway.');\n        }\n        if (!await this.hasRealInvoker()) {\n            throw new WalletDisconnectedError('Wallet is not connected');\n        }\n        if (this.raw.source !== (await this.getAccount()).accountId()) {\n            throw new Error(`You must submit the transaction with the account that originally created it. Please switch to the wallet with \"${this.raw.source}\" as its public key.`);\n        }\n        if ((await this.needsNonInvokerSigningBy()).length) {\n            throw new NeedsMoreSignaturesError('Transaction requires more signatures. See `needsNonInvokerSigningBy` for details.');\n        }\n        return await SentTransaction.init(this.options, this, secondsToWait);\n    };\n    getStorageExpiration = async () => {\n        const key = new Contract(this.options.contractId).getFootprint()[1];\n        const expirationKey = xdr.LedgerKey.expiration(new xdr.LedgerKeyExpiration({ keyHash: hash(key.toXDR()) }));\n        const entryRes = await this.server.getLedgerEntries(expirationKey);\n        if (!(entryRes.entries && entryRes.entries.length))\n            throw new Error('failed to get ledger entry');\n        return entryRes.entries[0].val.expiration().expirationLedgerSeq();\n    };\n    /**\n     * Get a list of accounts, other than the invoker of the simulation, that\n     * need to sign auth entries in this transaction.\n     *\n     * Soroban allows multiple people to sign a transaction. Someone needs to\n     * sign the final transaction envelope; this person/account is called the\n     * _invoker_, or _source_. Other accounts might need to sign individual auth\n     * entries in the transaction, if they're not also the invoker.\n     *\n     * This function returns a list of accounts that need to sign auth entries,\n     * assuming that the same invoker/source account will sign the final\n     * transaction envelope as signed the initial simulation.\n     *\n     * One at a time, for each public key in this array, you will need to\n     * serialize this transaction with `toJSON`, send to the owner of that key,\n     * deserialize the transaction with `txFromJson`, and call\n     * {@link signAuthEntries}. Then re-serialize and send to the next account\n     * in this list.\n     */\n    needsNonInvokerSigningBy = async ({ includeAlreadySigned = false, } = {}) => {\n        if (!this.raw) {\n            throw new Error('Transaction has not yet been simulated');\n        }\n        // We expect that any transaction constructed by these libraries has a\n        // single operation, which is an InvokeHostFunction operation. The host\n        // function being invoked is the contract method call.\n        if (!(\"operations\" in this.raw)) {\n            throw new Error(`Unexpected Transaction type; no operations: ${JSON.stringify(this.raw)}`);\n        }\n        const rawInvokeHostFunctionOp = this.raw\n            .operations[0];\n        return [...new Set((rawInvokeHostFunctionOp.auth ?? []).filter(entry => entry.credentials().switch() ===\n                xdr.SorobanCredentialsType.sorobanCredentialsAddress() &&\n                (includeAlreadySigned ||\n                    entry.credentials().address().signature().switch().name === 'scvVoid')).map(entry => StrKey.encodeEd25519PublicKey(entry.credentials().address().address().accountId().ed25519())))];\n    };\n    preImageFor(entry, signatureExpirationLedger) {\n        const addrAuth = entry.credentials().address();\n        return xdr.HashIdPreimage.envelopeTypeSorobanAuthorization(new xdr.HashIdPreimageSorobanAuthorization({\n            networkId: hash(Buffer.from(this.options.networkPassphrase)),\n            nonce: addrAuth.nonce(),\n            invocation: entry.rootInvocation(),\n            signatureExpirationLedger,\n        }));\n    }\n    /**\n     * If {@link needsNonInvokerSigningBy} returns a non-empty list, you can serialize\n     * the transaction with `toJSON`, send it to the owner of one of the public keys\n     * in the map, deserialize with `txFromJSON`, and call this method on their\n     * machine. Internally, this will use `signAuthEntry` function from connected\n     * `wallet` for each.\n     *\n     * Then, re-serialize the transaction and either send to the next\n     * `needsNonInvokerSigningBy` owner, or send it back to the original account\n     * who simulated the transaction so they can {@link sign} the transaction\n     * envelope and {@link send} it to the network.\n     *\n     * Sending to all `needsNonInvokerSigningBy` owners in parallel is not currently\n     * supported!\n     */\n    signAuthEntries = async (\n    /**\n     * When to set each auth entry to expire. Could be any number of blocks in\n     * the future. Can be supplied as a promise or a raw number. Default:\n     * contract's current `persistent` storage expiration date/ledger\n     * number/block.\n     */\n    expiration = this.getStorageExpiration()) => {\n        if (!this.raw)\n            throw new Error('Transaction has not yet been assembled or simulated');\n        const needsNonInvokerSigningBy = await this.needsNonInvokerSigningBy();\n        if (!needsNonInvokerSigningBy)\n            throw new NoUnsignedNonInvokerAuthEntriesError('No unsigned non-invoker auth entries; maybe you already signed?');\n        const publicKey = await this.getPublicKey();\n        if (!publicKey)\n            throw new Error('Could not get public key from wallet; maybe Freighter is not signed in?');\n        if (needsNonInvokerSigningBy.indexOf(publicKey) === -1)\n            throw new Error(`No auth entries for public key \"${publicKey}\"`);\n        const wallet = await this.getWallet();\n        const rawInvokeHostFunctionOp = this.raw\n            .operations[0];\n        const authEntries = rawInvokeHostFunctionOp.auth ?? [];\n        for (const [i, entry] of authEntries.entries()) {\n            if (entry.credentials().switch() !==\n                xdr.SorobanCredentialsType.sorobanCredentialsAddress()) {\n                // if the invoker/source account, then the entry doesn't need explicit\n                // signature, since the tx envelope is already signed by the source\n                // account, so only check for sorobanCredentialsAddress\n                continue;\n            }\n            const pk = StrKey.encodeEd25519PublicKey(entry.credentials().address().address().accountId().ed25519());\n            // this auth entry needs to be signed by a different account\n            // (or maybe already was!)\n            if (pk !== publicKey)\n                continue;\n            authEntries[i] = await authorizeEntry(entry, async (preimage) => Buffer.from(await wallet.signAuthEntry(preimage.toXDR('base64')), 'base64'), await expiration, this.options.networkPassphrase);\n        }\n    };\n    get isReadCall() {\n        const authsCount = this.simulationData.result.auth.length;\n        const writeLength = this.simulationData.transactionData.resources().footprint().readWrite().length;\n        return (authsCount === 0) && (writeLength === 0);\n    }\n    hasRealInvoker = async () => {\n        const account = await this.getAccount();\n        return account.accountId() !== NULL_ACCOUNT;\n    };\n}\n/**\n * A transaction that has been sent to the Soroban network. This happens in two steps:\n *\n * 1. `sendTransaction`: initial submission of the transaction to the network.\n *    This step can run into problems, and will be retried with exponential\n *    backoff if it does. See all attempts in `sendTransactionResponseAll` and the\n *    most recent attempt in `sendTransactionResponse`.\n * 2. `getTransaction`: once the transaction has been submitted to the network\n *    successfully, you need to wait for it to finalize to get the results of the\n *    transaction. This step can also run into problems, and will be retried with\n *    exponential backoff if it does. See all attempts in\n *    `getTransactionResponseAll` and the most recent attempt in\n *    `getTransactionResponse`.\n */\nclass SentTransaction {\n    options;\n    assembled;\n    server;\n    signed;\n    sendTransactionResponse;\n    sendTransactionResponseAll;\n    getTransactionResponse;\n    getTransactionResponseAll;\n    constructor(options, assembled) {\n        this.options = options;\n        this.assembled = assembled;\n        this.server = new SorobanRpc.Server(this.options.rpcUrl, {\n            allowHttp: this.options.rpcUrl.startsWith(\"http://\"),\n        });\n        this.assembled = assembled;\n    }\n    static init = async (options, assembled, secondsToWait = 10) => {\n        const tx = new SentTransaction(options, assembled);\n        return await tx.send(secondsToWait);\n    };\n    send = async (secondsToWait = 10) => {\n        const wallet = await this.assembled.getWallet();\n        this.sendTransactionResponseAll = await withExponentialBackoff(async (previousFailure) => {\n            if (previousFailure) {\n                // Increment transaction sequence number and resimulate before trying again\n                // Soroban transaction can only have 1 operation\n                const op = this.assembled.raw.operations[0];\n                this.assembled.raw = new TransactionBuilder(await this.assembled.getAccount(), {\n                    fee: this.assembled.raw.fee,\n                    networkPassphrase: this.options.networkPassphrase,\n                })\n                    .setTimeout(TimeoutInfinite)\n                    .addOperation(Operation.invokeHostFunction({ ...op, auth: op.auth ?? [] }))\n                    .build();\n                await this.assembled.simulate();\n            }\n            const signature = await wallet.signTransaction(this.assembled.raw.toXDR(), {\n                networkPassphrase: this.options.networkPassphrase,\n            });\n            this.signed = TransactionBuilder.fromXDR(signature, this.options.networkPassphrase);\n            return this.server.sendTransaction(this.signed);\n        }, resp => resp.status !== \"PENDING\", secondsToWait);\n        this.sendTransactionResponse = this.sendTransactionResponseAll[this.sendTransactionResponseAll.length - 1];\n        if (this.sendTransactionResponse.status !== \"PENDING\") {\n            throw new Error(`Tried to resubmit transaction for ${secondsToWait} seconds, but it's still failing. ` +\n                `All attempts: ${JSON.stringify(this.sendTransactionResponseAll, null, 2)}`);\n        }\n        const { hash } = this.sendTransactionResponse;\n        this.getTransactionResponseAll = await withExponentialBackoff(() => this.server.getTransaction(hash), resp => resp.status === SorobanRpc.Api.GetTransactionStatus.NOT_FOUND, secondsToWait);\n        this.getTransactionResponse = this.getTransactionResponseAll[this.getTransactionResponseAll.length - 1];\n        if (this.getTransactionResponse.status === SorobanRpc.Api.GetTransactionStatus.NOT_FOUND) {\n            console.error(`Waited ${secondsToWait} seconds for transaction to complete, but it did not. ` +\n                `Returning anyway. Check the transaction status manually. ` +\n                `Sent transaction: ${JSON.stringify(this.sendTransactionResponse, null, 2)}\\n` +\n                `All attempts to get the result: ${JSON.stringify(this.getTransactionResponseAll, null, 2)}`);\n        }\n        return this;\n    };\n    get result() {\n        // 1. check if transaction was submitted and awaited with `getTransaction`\n        if (\"getTransactionResponse\" in this &&\n            this.getTransactionResponse) {\n            // getTransactionResponse has a `returnValue` field unless it failed\n            if (\"returnValue\" in this.getTransactionResponse) {\n                return this.options.parseResultXdr(this.getTransactionResponse.returnValue);\n            }\n            // if \"returnValue\" not present, the transaction failed; return without parsing the result\n            throw new Error(\"Transaction failed! Cannot parse result.\");\n        }\n        // 2. otherwise, maybe it was merely sent with `sendTransaction`\n        if (this.sendTransactionResponse) {\n            const errorResult = this.sendTransactionResponse.errorResult?.result();\n            if (errorResult) {\n                throw new SendFailedError(`Transaction simulation looked correct, but attempting to send the transaction failed. Check \\`simulation\\` and \\`sendTransactionResponseAll\\` to troubleshoot. Decoded \\`sendTransactionResponse.errorResultXdr\\`: ${errorResult}`);\n            }\n            throw new SendResultOnlyError(`Transaction was sent to the network, but not yet awaited. No result to show. Await transaction completion with \\`getTransaction(sendTransactionResponse.hash)\\``);\n        }\n        // 3. finally, if neither of those are present, throw an error\n        throw new Error(`Sending transaction failed: ${JSON.stringify(this.assembled)}`);\n    }\n}\n/**\n * Keep calling a `fn` for `secondsToWait` seconds, if `keepWaitingIf` is true.\n * Returns an array of all attempts to call the function.\n */\nasync function withExponentialBackoff(fn, keepWaitingIf, secondsToWait, exponentialFactor = 1.5, verbose = false) {\n    const attempts = [];\n    let count = 0;\n    attempts.push(await fn());\n    if (!keepWaitingIf(attempts[attempts.length - 1]))\n        return attempts;\n    const waitUntil = new Date(Date.now() + secondsToWait * 1000).valueOf();\n    let waitTime = 1000;\n    let totalWaitTime = waitTime;\n    while (Date.now() < waitUntil && keepWaitingIf(attempts[attempts.length - 1])) {\n        count++;\n        // Wait a beat\n        if (verbose) {\n            console.info(`Waiting ${waitTime}ms before trying again (bringing the total wait time to ${totalWaitTime}ms so far, of total ${secondsToWait * 1000}ms)`);\n        }\n        await new Promise(res => setTimeout(res, waitTime));\n        // Exponential backoff\n        waitTime = waitTime * exponentialFactor;\n        if (new Date(Date.now() + waitTime).valueOf() > waitUntil) {\n            waitTime = waitUntil - Date.now();\n            if (verbose) {\n                console.info(`was gonna wait too long; new waitTime: ${waitTime}ms`);\n            }\n        }\n        totalWaitTime = waitTime + totalWaitTime;\n        // Try again\n        attempts.push(await fn(attempts[attempts.length - 1]));\n        if (verbose && keepWaitingIf(attempts[attempts.length - 1])) {\n            console.info(`${count}. Called ${fn}; ${attempts.length} prev attempts. Most recent: ${JSON.stringify(attempts[attempts.length - 1], null, 2)}`);\n        }\n    }\n    return attempts;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}